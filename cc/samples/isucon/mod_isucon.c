/* 
  mod_isucon.c -- Apache isucon module
  [Autogenerated via ``apxs -n isucon -g'']

    $ apxs -c -i mod_isucon.c

    #   httpd.conf
    LoadModule isucon_module modules/mod_isucon.so
    <Location /isucon>
    SetHandler isucon
    </Location>
*/ 

#include "httpd.h"
#include "http_log.h"
#include "http_config.h"
#include "http_protocol.h"
#include "apr_dbd.h"
#include "mod_dbd.h"
#include "ap_config.h"
#include "apr_tables.h"
#include "apr_strings.h"

typedef struct {
    char *dbname;
    char *host;
    char *port;
    char *username;
    char *password;

    int  pool;
} isucon_config_t;

module AP_MODULE_DECLARE_DATA isucon_module;

static void *create_dir_config(apr_pool_t *p, char *dir)
{
    isucon_config_t *config = (isucon_config_t *)apr_palloc(p, sizeof(isucon_config_t));

    return config;
}

static const char *set_dbname(cmd_parms *parms, void *mconfig, const char *w)
{
    isucon_config_t *config = (isucon_config_t *)mconfig;

    config->dbname = apr_pstrdup(parms->pool, w);

    return NULL;
}

static const command_rec isucon_cmds[] =
{
  AP_INIT_TAKE1("dbname", set_dbname, NULL, OR_ALL, "Not dbname."),
  {NULL}
};


static apr_table_t *parse_post(request_rec *r, const char *query_string)
{
    apr_table_t *table;
    const char *key;
    const char *val;

    table = apr_table_make(r->pool, 8);

    if (query_string == NULL) {
        return table;
    }

    while (*query_string && (val = ap_getword(r->pool, &query_string, '&'))) {
        key = ap_getword(r->pool, &val, '=');

        ap_unescape_url((char*)key);
        ap_unescape_url((char*)val);
        apr_table_merge(table, key, val);
    }

    return table;
}

static apr_array_header_t *parse_path(request_rec *r, const char *path)
{
    apr_array_header_t *path_split;
    const char *val;
    char *entry;

    if (path == NULL) {
        return NULL;
    }

    path_split = apr_array_make(r->pool, 8, sizeof(apr_array_header_t*));

    while (*path && (val = ap_getword(r->pool, &path, '/'))) {
    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, ">> path = %s", val);
        entry = apr_array_push(path_split);
        *(char **)entry = apr_pstrdup(r->pool, val);
    }

    return path_split;
}

static void dump_query_string(request_rec *r, const apr_table_t *table)
{
    const apr_array_header_t *arr;
    apr_table_entry_t *entry;
    int i;

    arr = apr_table_elts(table);

    for (i = 0; i < arr->nelts; i++) {
        entry = (apr_table_entry_t *)(arr->elts + (arr->elt_size * i));
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "  key=[%s], val=[%s]", entry->key, entry->val);
    }

    return;
}

static apr_array_header_t *exec_select(request_rec *r, char *sql)
{
    apr_array_header_t *data;
    apr_array_header_t *items;
    apr_array_header_t *arr;
    int ret;
    ap_dbd_t *dbd;
    apr_dbd_results_t *res;
    apr_dbd_row_t *row;
    int rows;
    int cols;
    int i;
    const char *val;
    char *entry;

    dbd = ap_dbd_acquire(r);
    if (dbd == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "Error: ap_dbd_acquire()");
        return NULL;
    }

    res = NULL;
    ret = apr_dbd_select(dbd->driver, r->pool, dbd->handle, &res, sql, 0);
    if (ret != 0) {
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "Error %d %s", ret, apr_dbd_error(dbd->driver, dbd->handle, ret));
        return NULL;
    }

    rows = apr_dbd_num_tuples(dbd->driver, res);
    cols = apr_dbd_num_cols(dbd->driver, res);

    data = apr_array_make(r->pool, rows, sizeof(apr_array_header_t*));

    row = NULL;
    while (apr_dbd_get_row(dbd->driver, r->pool, res, &row, -1) != -1) {
        items = apr_array_make(r->pool, cols, sizeof(char*));

        for (i = 0; i < cols; i++) {
            val = apr_dbd_get_entry(dbd->driver, row, i);

            entry = apr_array_push(items);
            *(char **)entry = apr_pstrdup(r->pool, val);
        }

        arr = apr_array_push(data);
        *(apr_array_header_t **)arr = items;
    }

    return data;
}

static int exec_query(request_rec *r, char *sql)
{
    int ret;
    ap_dbd_t *dbd;
    apr_dbd_results_t *res;
    apr_dbd_row_t *row;
    int affected_rows = 0;

    dbd = ap_dbd_acquire(r);
    if (dbd == NULL) {
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "Error: ap_dbd_acquire()");
        return -1;
    }

    affected_rows = 0;
    ret = apr_dbd_query(dbd->driver, dbd->handle, &affected_rows, sql);
    if (ret != 0) {
        ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "Error %d %s", ret, apr_dbd_error(dbd->driver, dbd->handle, ret));
        return -1;
    }

    return affected_rows;
}


/* The sample content handler */
static int isucon_handler(request_rec *r)
{
    if (strcmp(r->handler, "isucon")) {
        return DECLINED;
    }
    r->content_type = "text/html";      

    if (r->header_only)
        return OK;

    {
        apr_array_header_t *p;

        p = parse_path(r, r->uri);
    }

    {
        int affected_rows;
        char *sql = "INSERT INTO memos (user, content, is_private, created_at) VALUES (\"mod_user\", \"isucon!\", 0, now())";

        affected_rows = exec_query(r, sql);
        ap_rprintf(r, "insert> affected_rows : [%d] ", affected_rows);
    }

    {
        int affected_rows;
        char *sql = "UPDATE memos SET content = \"@@@\" WHERE id = \"2\"";

        affected_rows = exec_query(r, sql);
        ap_rprintf(r, "update> affected_rows : [%d] ", affected_rows);
    }

    {
        apr_array_header_t *data;
        apr_array_header_t *items;
        char *val;
        int i, j;

        data = exec_select(r, "SELECT * FROM memos");

        if (data != NULL) {
            for (i = 0; i < data->nelts; i++) {
                items = APR_ARRAY_IDX(data, i, apr_array_header_t *);
                for (j = 0; j < items->nelts; j++) {
                    val = APR_ARRAY_IDX(items, j, char *);

                    ap_rprintf(r, "[%s] ", val);
                }
                ap_rputs("<br />\n", r);
            }
            apr_array_clear(data);
        }
    }

    {
        apr_array_header_t *data;
        apr_array_header_t *items;
        char *val;
        int i, j;
        char *select_sql = "select max(id) from memos";
        int max_id;

        data = exec_select(r, select_sql);
        if (data != NULL) {
            for (i = 0; i < data->nelts; i++) {
                items = APR_ARRAY_IDX(data, i, apr_array_header_t *);
                for (j = 0; j < items->nelts; j++) {
                    val = APR_ARRAY_IDX(items, j, char *);

                    ap_rprintf(r, "[%s] ", val);
                }
                ap_rputs("<br />\n", r);
            }
            apr_array_clear(data);
        }

        int affected_rows;
        char *sql = "UPDATE memos SET content = \"@@@\" WHERE id = \"2\"";

        affected_rows = exec_query(r, sql);
        ap_rprintf(r, "update> affected_rows : [%d] ", affected_rows);
    }

    {
        ap_rprintf(r, "http method : [%s] ", r->method);

        apr_table_t *table = parse_post(r, r->args);

        dump_query_string(r, table);
    }

    {
//        isucon_config_t *config = (isucon_config_t *)ap_get_module_config(r->per_dir_config, &isucon_module);
    }

    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "args: %s", r->args);
    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "uri: %s", r->uri);
    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, "unparsed uri: %s", r->unparsed_uri);

    ap_rputs("The sample page from mod_isucon.c\n", r);
    return OK;
}

static void isucon_register_hooks(apr_pool_t *p)
{
    ap_hook_handler(isucon_handler, NULL, NULL, APR_HOOK_MIDDLE);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA isucon_module = {
    STANDARD20_MODULE_STUFF, 
    create_dir_config,     /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    isucon_cmds,           /* table of config file commands       */
    isucon_register_hooks  /* register hooks                      */
};

